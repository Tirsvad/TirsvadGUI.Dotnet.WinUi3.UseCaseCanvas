#nullable enable
using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TirsvadGUI.ArtefactsGenerator.Generators;

[Generator]
public class RelayCommandGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Attributes.RelayCommandAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (s, _) => IsCandidate(s),
            transform: static (ctx, _) => GetSemanticTargetIfValid(ctx))
            .Where(static m => m is not null)
            .Select((x, _) => x!);

        // Group by containing type
        var grouped = provider.Collect();

        context.RegisterSourceOutput(grouped, (spc, collected) => Execute(collected, spc));
    }

    private static bool IsCandidate(SyntaxNode syntaxNode) => syntaxNode is MethodDeclarationSyntax m && m.AttributeLists.Count > 0;

    private static IMethodSymbol? GetSemanticTargetIfValid(GeneratorSyntaxContext context)
    {
        if (context.Node is not MethodDeclarationSyntax methodNode) return null;
        if (context.SemanticModel.GetDeclaredSymbol(methodNode) is not IMethodSymbol methodSymbol) return null;


        // Check for attribute by metadata name
        var attr = methodSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttributeFullName
                              || a.AttributeClass?.Name == "RelayCommandAttribute");
        if (attr is null) return null;


        // Return a nullable tuple so null can be returned from other branches
        return methodSymbol;
    }

    private static void Execute(ImmutableArray<IMethodSymbol> methods, SourceProductionContext context)
    {
        if (methods.IsDefaultOrEmpty) return;

        // Group methods by containing type
        var methodsByType = methods.GroupBy(m => m.ContainingType, SymbolEqualityComparer.Default);

        foreach (var group in methodsByType)
        {
            var typeSymbol = group.Key;
            if (typeSymbol is null) return;

            var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace ? null : typeSymbol.ContainingNamespace.ToDisplayString();

            var typeName = typeSymbol.Name;
            var accessibility = GetAccessibility(typeSymbol);
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            // Write namespace if applicable
            if (namespaceName is not null)
            {
                sb.AppendLine($"namespace {namespaceName};");
            }

            // Keep same accessibility and partial modifier
            var partialModifier = "partial";
            sb.AppendLine($"{accessibility} {partialModifier} class {typeName}");
            sb.AppendLine("{");
            foreach (var item in group)
            {
                var method = item;
                // You may need to retrieve the attribute again if needed:
                var attr = method.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AttributeFullName
                                      || a.AttributeClass?.Name == "RelayCommandAttribute");
                if (attr == null) continue;
                GenerateForMethod(sb, method, attr);
            }

            sb.AppendLine("}");

            var hintName = $"{typeSymbol.ContainingNamespace.ToDisplayString().Replace('.', '_')}_{typeName}_RelayCommands.g.cs";
            context.AddSource(hintName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }


    private static void GenerateForMethod(StringBuilder sb, IMethodSymbol method, AttributeData attr)
    {
        // Only instance methods
        //if (method.IsStatic) return;

        var methodName = method.Name;
        // Read CommandName from attribute ctor args if present
        string? explicitName = null;
        bool allowConcurrent = false;

        if (attr.ConstructorArguments.Length > 0)
        {
            // There are overloads: (string), (string,bool), (bool)
            foreach (var arg in attr.ConstructorArguments)
            {
                if (arg.IsNull) continue;
                if (arg.Type?.SpecialType == SpecialType.System_String && explicitName is null)
                {
                    explicitName = arg.Value as string;
                }
                else if (arg.Type != null && arg.Type.SpecialType == SpecialType.System_Boolean)
                {
                    // If a string was not provided, first bool ctor could be the single bool ctor
                    allowConcurrent = (bool)arg.Value!;
                }
            }
        }

        // Attribute may have named argument `AllowConcurrentExecutions` as well, check that:
        var namedAllow = attr.NamedArguments.FirstOrDefault(kv => kv.Key == "AllowConcurrentExecutions");
        if (namedAllow.Value.Value is bool namedBool)
        {
            allowConcurrent = namedBool;
        }

        var propertyName = explicitName ?? (methodName.EndsWith("Command") ? methodName : methodName + "Command");

        // Backing field name
        var fieldName = $"_{Char.ToLowerInvariant(propertyName[0])}{propertyName.Substring(1)}";
        // Determine parameter handling
        var parameters = method.Parameters;
        string ctorArg;
        bool returnsTask = IsTaskReturning(method.ReturnType);

        if (parameters.Length == 0)
        {
            // Parameterless method
            if (returnsTask)
            {
                // Func<Task> -> RelayCommand(Func<Task>)
                ctorArg = $"{methodName}";
                // Use the Func<Task> constructor; method name (if async) can be used directly.
                sb.AppendLine($"        private global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand? {fieldName};");
                sb.AppendLine($"        public global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand {propertyName} => {fieldName} ??= new global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand({ctorArg}, allowConcurrentExecutions: {allowConcurrent.ToString().ToLowerInvariant()}, commandName: \"{propertyName}\");");
                sb.AppendLine();
            }
            else
            {
                // Action
                ctorArg = methodName;
                sb.AppendLine($"        private global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand? {fieldName};");
                sb.AppendLine($"        public global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand {propertyName} => {fieldName} ??= new global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand({ctorArg}, allowConcurrentExecutions: {allowConcurrent.ToString().ToLowerInvariant()}, commandName: \"{propertyName}\");");
                sb.AppendLine();
            }
        }
        else if (parameters.Length == 1)
        {
            var p = parameters[0];
            var pType = p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            // Use object-parameter constructor and cast inside lambda if parameter is not object?
            if (returnsTask)
            {
                // Func<object?, Task> overload
                // If parameter type is object or object?, forward directly; else cast
                var cast = p.Type.SpecialType == SpecialType.None && pType == "object" ? "parameter" : $"({pType})parameter";
                sb.AppendLine($"        private global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand? {fieldName};");
                sb.AppendLine($"        public global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand {propertyName} => {fieldName} ??= new global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand(async (object? parameter) => await {methodName}({cast})!, allowConcurrentExecutions: {allowConcurrent.ToString().ToLowerInvariant()}, commandName: \"{propertyName}\");");
                sb.AppendLine();
            }
            else
            {
                var cast = p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "object" ? "parameter" : $"({pType})parameter";
                sb.AppendLine($"        private global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand? {fieldName};");
                sb.AppendLine($"        public global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand {propertyName} => {fieldName} ??= new global::TirsvadGUI.ArtefactsGenerator.Mvvm.Input.Commands.RelayCommand((object? parameter) => {methodName}({cast}), allowConcurrentExecutions: {allowConcurrent.ToString().ToLowerInvariant()}, commandName: \"{propertyName}\");");
                sb.AppendLine();
            }
        }
        else
        {
            // Unsupported signature: more than one parameter
            // Emit no code for this method.
        }
    }


    private static bool IsTaskReturning(ITypeSymbol type)
    {
        var name = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return name == "global::System.Threading.Tasks.Task"
            || name == "global::System.Threading.Tasks.ValueTask"
            || name.StartsWith("global::System.Threading.Tasks.Task<")
            || name.StartsWith("global::System.Threading.Tasks.ValueTask<");
    }

    private static string GetAccessibility(ISymbol type)
    {
        return type.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "protected internal",
            Accessibility.ProtectedOrInternal => "private protected",
            _ => "public",
        };
    }


    private static void Execute(Compilation compilation, ImmutableArray<IMethodSymbol?> methods, SourceProductionContext context)
    {
        var code = """
            namespace TirsvadGUI.ArtefactsGenerator.Generated
            {
                public static class GeneratedClass
                {
                    public static void GeneratedMethod()
                    {
                        // Generated code goes here
                        var a = 42;
                    }
                }
            }
            """;

        context.AddSource("MyGeneratedClass.g.cs", code);
    }
}
